#pragma kernel Blur
#pragma kernel CA2Mesh

#define PI 3.14159265358979323846
#define EULER 2.71828182845904523536
#define DIMENSIONS 2
#define NUMBER_OF_ELEMENTS 3
#define ADDRESS(x,y,z,size) x + y * size[0] + z * size[0] * size[1]

struct Cell
{
	half content[NUMBER_OF_ELEMENTS];
	half volume;
	half temperature;
};

Texture2D<float2> DepthTex;
RWTexture2D<float2> BlurTex;
RWTexture2D<float4> ShadedTex;

float3 lightDirection;

float maxDepth = 50;

float4x4 projMatrixInv;
float4x4 viewMatrixInv;

int2 blurDir;

static int stdDev = 5;

const int filterRadius = 10;
const float blurScale = 0.1;
const float blurDepthFalloff = 0.8;

StructuredBuffer<Cell> currentGeneration;
AppendStructuredBuffer<half4> mesh;

uint3 size;

[numthreads(16, 8, 8)]
void CA2Mesh (uint3 id : SV_DispatchThreadID)
{
	if (currentGeneration[ADDRESS(id.x, id.y, id.z, size)].volume > 0.1)
	{
		mesh.Append(half4(id.x / half(size.x), id.y / half(size.y), id.z / half(size.z), currentGeneration[ADDRESS(id.x, id.y, id.z, size)].volume));
	}
}


[numthreads(32, 32, 1)]
void Blur(uint3 id : SV_DispatchThreadID)
{
	int2 index;
	float result = 0;

	//[unroll(2 * DIMENSIONS)]
	//for (int x = -DIMENSIONS; x < DIMENSIONS; ++x)
	//{
	//	[unroll(2 * DIMENSIONS)]
	//	for (int y = -DIMENSIONS; y < DIMENSIONS; ++y)
	//	{
	//		index = int2(id.xy) + int2(x, y);
	//		if (index.x >= 0 && index.y >= 0 && index.x < 256 && index.y < 256)
	//		{
	//			result += (1 / (2.0*PI*stdDev*stdDev)) * pow(EULER, -((x*x + y*y) / (2.0*stdDev*stdDev))) * DepthTex[index];
	//		}
	//	}
	//}
	BlurTex[id.xy] = DepthTex[id.xy];

	//float depth = Input[id.xy];
	//if (depth == 1.0f) 
	//{
	//	Result[id.xy] = 0;
	//	return;
	//}
	//float sum = 0;
	//float wsum = 0;
	//for (int x = -filterRadius; x <= filterRadius; ++x)
	//{
	//	if (id.x + x >= 0 && id.x + x < 256)
	//	{
	//		float samp = Input[id.xy + x*blurDir];
	//		// spatial domain
	//		float r = x * blurScale;
	//		float w = exp(-r*r);
	//		// range domain
	//		float r2 = (samp - depth) * blurDepthFalloff;
	//		float g = exp(-r2*r2);
	//		sum += samp * w * g;
	//		wsum += w * g;
	//	}
	//}
	//if (wsum > 0.0) 
	//{
	//	sum /= wsum;
	//}
	//Result[id.xy] = sum;
}
