using UnityEngine;

namespace GPUFluid
{
    [RequireComponent(typeof(Camera))]
    public class ScreenSpaceFluidVisualisation : MonoBehaviour
    {
        public LayerMask lightLayer;
        public Material view;

        private RenderTexture depthTex;
        private RenderTexture blurTex;
        private RenderTexture shadedTex;

        //The scale of the visualisation
        public Vector3 scale;

        //The size of the CellularAutomaton
        private GridDimensions dimensions;

        //A compute shader that executes the Marching Cubes algorithm
        private ComputeShader cs;
        private int cs2Mesh;
        private int blur;
        private int shading;

        //The material for the mesh, that is generated by the Marching Cubes algorithm
        public Material material;

        private ComputeBuffer mesh;

        //A compute buffer that stores the number of triangles/quads generated by the Marching Cubes algorith
        private ComputeBuffer args;
        private int[] data;

        private int[] renderTextureSize = new int[] { 512, 512 };

        public void Initialize(GridDimensions dimensions)
        {
            this.dimensions = dimensions;

            depthTex = new RenderTexture(renderTextureSize[0], renderTextureSize[1], 0, RenderTextureFormat.RFloat);
            depthTex.enableRandomWrite = true;
            depthTex.Create();
            GetComponent<Camera>().targetTexture = depthTex;

            blurTex = new RenderTexture(renderTextureSize[0], renderTextureSize[1], 0, RenderTextureFormat.RFloat);
            blurTex.enableRandomWrite = true;
            blurTex.Create();

            shadedTex = new RenderTexture(renderTextureSize[0], renderTextureSize[1], 0);
            shadedTex.enableRandomWrite = true;
            shadedTex.Create();

            view.SetTexture("_MainTex", shadedTex);

            InitializeComputeBuffer();
            InitializeShader();
        }

        private void InitializeComputeBuffer()
        {
            args = new ComputeBuffer(4, sizeof(int), ComputeBufferType.IndirectArguments);
            data = new int[4] { 0, 1, 0, 0 };
            args.SetData(data);

            mesh = new ComputeBuffer((dimensions.x * dimensions.y * dimensions.z) * 4096, 4 * sizeof(float), ComputeBufferType.Append);

            ComputeBuffer.CopyCount(mesh, args, 0);
        }

        private void InitializeShader()
        {
            cs = Resources.Load<ComputeShader>("ComputeShader/ScreenSpaceFluidRendering/ScreenSpaceFluidRendering");
            cs.SetInts("size", new int[] { dimensions.x * 16, dimensions.y * 16, dimensions.z * 16 });

            cs2Mesh = cs.FindKernel("CA2Mesh");
            blur = cs.FindKernel("Blur");
            shading = cs.FindKernel("Shading");

            material.SetVector("scale", new Vector4(scale.x, scale.y, scale.z, 1));

            cs.SetInts("blurDir", new int[] { 1, 0 });
            cs.SetFloats("projMatrixInv", Matrix2FloatArray(GetComponent<Camera>().projectionMatrix.inverse));

            cs.SetBuffer(cs2Mesh, "mesh", mesh);

            cs.SetTexture(blur, "DepthTex", depthTex);
            cs.SetTexture(blur, "BlurTex", blurTex);
            cs.SetTexture(shading, "BlurTex", blurTex);
            cs.SetTexture(shading, "ShadedTex", shadedTex);
        }

        public void Render(ComputeBuffer cells)
        {
            mesh.SetCounterValue(0);
            cs.SetBuffer(cs2Mesh, "currentGeneration", cells);
            cs.Dispatch(cs2Mesh, dimensions.x, dimensions.y * 2, dimensions.z * 2);

            cs.Dispatch(blur, renderTextureSize[0] / 32, renderTextureSize[1] / 32, 1);

            cs.SetFloats("viewMatrixInv", Matrix2FloatArray(GetComponent<Camera>().worldToCameraMatrix.inverse));

            Quaternion lightDirection = Quaternion.LookRotation(Light.GetLights(LightType.Directional, lightLayer.value)[0].transform.localEulerAngles);
            cs.SetFloats("lightDirection", new float[] { lightDirection.x, lightDirection.y, lightDirection.z });
            cs.Dispatch(shading, renderTextureSize[0] / 32, renderTextureSize[1] / 32, 1);
        }

        void OnPostRender()
        {
            material.SetPass(0);

            ComputeBuffer.CopyCount(mesh, args, 0);
            material.SetBuffer("mesh", mesh);
            Graphics.DrawProceduralIndirect(MeshTopology.Points, args);
        }

        float[] Matrix2FloatArray(Matrix4x4 mat)
        {
            return new float[] { mat.m00, mat.m01, mat.m02, mat.m03,
                                mat.m10, mat.m11, mat.m12, mat.m13,
                                mat.m20, mat.m21, mat.m22, mat.m23,
                                mat.m30, mat.m31, mat.m32, mat.m33};
        }

        void OnDisable()
        {
            mesh.Release();
            args.Release();
        }
    }
}