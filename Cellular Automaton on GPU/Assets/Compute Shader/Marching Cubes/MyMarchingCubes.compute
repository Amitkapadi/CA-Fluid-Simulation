#pragma kernel Initialize
#pragma kernel CSMain

#define NUMBER_OF_ELEMENTS 3
#define ADDRESS(x,y,z,size) x + y * size + z * size * size

struct Cell
{
	int volume;
	int content[NUMBER_OF_ELEMENTS];
	float temperature;
};

struct Quad
{
	float3 vertex[4];
};

float scale;
uint size;
int maxVolume;

RWStructuredBuffer<Cell> newGeneration;
StructuredBuffer<Cell> currentGeneration;
AppendStructuredBuffer<Quad> quads;

[numthreads(8, 8, 8)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
	if (id.x == 8 && id.z == 8)
	{
		newGeneration[ADDRESS(id.x, id.y, id.z, size)].volume = 1;
	}
	else
	{
		newGeneration[ADDRESS(id.x, id.y, id.z, size)].volume = 0;
	}
}

[numthreads(8, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Cell current = currentGeneration[ADDRESS(id.x, id.y, id.z, size)];
	Cell down = currentGeneration[ADDRESS(id.x, (id.y - 1), id.z, size)];
	Cell up = currentGeneration[ADDRESS(id.x, (id.y + 1), id.z, size)];
	Cell left = currentGeneration[ADDRESS((id.x - 1), id.y, id.z, size)];
	Cell right = currentGeneration[ADDRESS((id.x + 1), id.y, id.z, size)];
	Cell front = currentGeneration[ADDRESS(id.x, id.y, (id.z - 1), size)];
	Cell back = currentGeneration[ADDRESS(id.x, id.y, (id.z + 1), size)];

	float maxVol = float(maxVolume);

	if (down.volume > 0 && (down.volume > current.volume || down.volume < maxVolume) && id.y > 0)
	{
		Quad quad;
		quad.vertex[0] = float3(id.x * scale,			id.y * scale - scale + (down.volume / maxVol) * scale, id.z * scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale - scale + (down.volume / maxVol) * scale, id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale - scale + (down.volume / maxVol) * scale, id.z * scale + scale);
		quad.vertex[3] = float3(id.x * scale,			id.y * scale - scale + (down.volume / maxVol) * scale, id.z * scale + scale);
		quads.Append(quad);
	}
	
	if (up.volume > 0 && (up.volume > current.volume || current.volume < maxVolume) && id.y < size - 1)
	{
		Quad quad;
		quad.vertex[3] = float3(id.x * scale,			id.y * scale + scale, id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale + scale, id.z * scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale + scale, id.z * scale + scale);
		quad.vertex[0] = float3(id.x * scale,			id.y * scale + scale, id.z * scale + scale);
		quads.Append(quad);
	}
	
	if (left.volume > 0 && left.volume > current.volume && id.x > 0)
	{
		Quad quad;
		quad.vertex[0] = float3(id.x * scale, id.y * scale,										id.z * scale);
		quad.vertex[1] = float3(id.x * scale, id.y * scale,										id.z * scale + scale);
		quad.vertex[2] = float3(id.x * scale, id.y * scale + (left.volume / maxVol) * scale,	id.z * scale + scale);
		quad.vertex[3] = float3(id.x * scale, id.y * scale + (left.volume / maxVol) * scale,	id.z * scale);
		quads.Append(quad);
	}
	
	if (right.volume > 0 && right.volume > current.volume && id.x < size - 1)
	{
		Quad quad;
		quad.vertex[3] = float3(id.x * scale + scale, id.y * scale,										id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale, id.y * scale,										id.z * scale + scale);
		quad.vertex[1] = float3(id.x * scale + scale, id.y * scale + (right.volume / maxVol) * scale,	id.z * scale + scale);
		quad.vertex[0] = float3(id.x * scale + scale, id.y * scale + (right.volume / maxVol) * scale,	id.z * scale);
		quads.Append(quad);
	}
	
	if (front.volume > 0 && front.volume > current.volume && id.z > 0)
	{
		Quad quad;
		quad.vertex[3] = float3(id.x * scale,			id.y * scale,									id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale,									id.z * scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale + (front.volume / maxVol) * scale, id.z * scale);
		quad.vertex[0] = float3(id.x * scale,			id.y * scale + (front.volume / maxVol) * scale, id.z * scale);
		quads.Append(quad);
	}
	
	if (back.volume > 0 && back.volume > current.volume && id.z < size - 1)
	{
		Quad quad;
		quad.vertex[0] = float3(id.x * scale,			id.y * scale,									id.z * scale + scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale,									id.z * scale + scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale + (back.volume / maxVol) * scale,	id.z * scale + scale);
		quad.vertex[3] = float3(id.x * scale,			id.y * scale + (back.volume / maxVol) * scale,	id.z * scale + scale);
		quads.Append(quad);
	}
}
