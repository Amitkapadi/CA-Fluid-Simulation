#pragma kernel CSMain

#define NUMBER_OF_ELEMENTS 3
#define ADDRESS(x,y,z,size) x + y * size + z * size * size

struct Cell
{
	float content[NUMBER_OF_ELEMENTS];
	int temperature;
};

struct Quad
{
	float3 vertex[4];
};

float scale;
uint size;

StructuredBuffer<Cell> currentGeneration;
AppendStructuredBuffer<Quad> quads;

float Volume(Cell cell)
{
	float volume = 0;
	[unroll(NUMBER_OF_ELEMENTS)]
	for (uint i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		volume += cell.content[i];
	}
	if (volume < 0.001)
	{
		return -1.0;
	}

	return volume;
}

[numthreads(16, 8, 8)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	Cell current = currentGeneration[ADDRESS(id.x, id.y, id.z, size)];
	Cell down = currentGeneration[ADDRESS(id.x, (id.y - 1), id.z, size)];
	Cell up = currentGeneration[ADDRESS(id.x, (id.y + 1), id.z, size)];
	Cell left = currentGeneration[ADDRESS((id.x - 1), id.y, id.z, size)];
	Cell right = currentGeneration[ADDRESS((id.x + 1), id.y, id.z, size)];
	Cell front = currentGeneration[ADDRESS(id.x, id.y, (id.z - 1), size)];
	Cell back = currentGeneration[ADDRESS(id.x, id.y, (id.z + 1), size)];

	float volumeCurrent = Volume(current);
	float volume = Volume(down);
	if (volume > 0 && (volume > volumeCurrent || volume < 1) && id.y > 0)
	{
		Quad quad;
		quad.vertex[0] = float3(id.x * scale,			id.y * scale - scale + volume * scale, id.z * scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale - scale + volume * scale, id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale - scale + volume * scale, id.z * scale + scale);
		quad.vertex[3] = float3(id.x * scale,			id.y * scale - scale + volume * scale, id.z * scale + scale);
		quads.Append(quad);
	}
	
	volume = Volume(up);
	if (volume > 0 && (volume > volumeCurrent || volumeCurrent < 1) && id.y < size - 1)
	{
		Quad quad;
		quad.vertex[3] = float3(id.x * scale,			id.y * scale + scale, id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale + scale, id.z * scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale + scale, id.z * scale + scale);
		quad.vertex[0] = float3(id.x * scale,			id.y * scale + scale, id.z * scale + scale);
		quads.Append(quad);
	}
	
	volume = Volume(left);
	if (volume > 0 && volume > volumeCurrent && id.x > 0)
	{
		Quad quad;
		quad.vertex[0] = float3(id.x * scale, id.y * scale,						id.z * scale);
		quad.vertex[1] = float3(id.x * scale, id.y * scale,						id.z * scale + scale);
		quad.vertex[2] = float3(id.x * scale, id.y * scale + volume * scale,	id.z * scale + scale);
		quad.vertex[3] = float3(id.x * scale, id.y * scale + volume * scale,	id.z * scale);
		quads.Append(quad);
	}
	
	volume = Volume(right);
	if (volume > 0 && volume > volumeCurrent && id.x < size - 1)
	{
		Quad quad;
		quad.vertex[3] = float3(id.x * scale + scale, id.y * scale,						id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale, id.y * scale,						id.z * scale + scale);
		quad.vertex[1] = float3(id.x * scale + scale, id.y * scale + volume * scale,	id.z * scale + scale);
		quad.vertex[0] = float3(id.x * scale + scale, id.y * scale + volume * scale,	id.z * scale);
		quads.Append(quad);
	}

	volume = Volume(front);
	if (volume > 0 && volume > volumeCurrent && id.z > 0)
	{
		Quad quad;
		quad.vertex[3] = float3(id.x * scale,			id.y * scale,					id.z * scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale,					id.z * scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale + volume * scale,	id.z * scale);
		quad.vertex[0] = float3(id.x * scale,			id.y * scale + volume * scale,	id.z * scale);
		quads.Append(quad);
	}

	volume = Volume(back);
	if (volume > 0 && volume > volumeCurrent && id.z < size - 1)
	{
		Quad quad;
		quad.vertex[0] = float3(id.x * scale,			id.y * scale,					id.z * scale + scale);
		quad.vertex[1] = float3(id.x * scale + scale,	id.y * scale,					id.z * scale + scale);
		quad.vertex[2] = float3(id.x * scale + scale,	id.y * scale + volume * scale,	id.z * scale + scale);
		quad.vertex[3] = float3(id.x * scale,			id.y * scale + volume * scale,	id.z * scale + scale);
		quads.Append(quad);
	}
}
