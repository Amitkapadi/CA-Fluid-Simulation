#pragma kernel Initialize
#pragma kernel UpdateX
#pragma kernel UpdateY
#pragma kernel UpdateZ

#define SOLID -300
#define MIN_TEMPERATURE -275
#define MAX_TEMPERATURE 1000000

#define NUMBER_OF_ELEMENTS 3
#define ADDRESS(x,y,z,size) x + y * size + z * size * size

struct Cell
{
	float content[NUMBER_OF_ELEMENTS];
	int temperature;
};

static float Viscosities[] =
{
	0, 0.01, 1
};

static float Densities[] =
{
	0.4, 1, 2
};

static float2 AggregationChangeTemperatures[] =
{
	float2(MAX_TEMPERATURE, 10),
	float2(MAX_TEMPERATURE, MIN_TEMPERATURE),
	float2(100, MIN_TEMPERATURE)
};

static int2 AggregationChangeElements[] =
{
	int2(-1, 2),
	int2(-1, -1),
	int2(0, -1)
};

static float temperatureSpread = 32;

StructuredBuffer<Cell> currentGeneration;
RWStructuredBuffer<Cell> newGeneration;

uint size;
uint3 offset;

uint4 fill;

[numthreads(16, 8, 8)]
void Initialize(uint3 id : SV_DispatchThreadID)
{
	if (id.x == 0 || id.y == 0 || id.z == 0 || id.x == size - 1 || id.y == size - 1 || id.z == size - 1 || (id.z == 20 && id.y < 3))
	{
		newGeneration[ADDRESS(id.x, id.y, id.z, size)].temperature = SOLID;

		for (uint i = 0; i < NUMBER_OF_ELEMENTS; ++i)
		{
			newGeneration[ADDRESS(id.x, id.y, id.z, size)].content[i] = SOLID;
		}
	}
	else
	{
		newGeneration[ADDRESS(id.x, id.y, id.z, size)].temperature = 20.0;

		for (uint i = 0; i < NUMBER_OF_ELEMENTS; ++i)
		{
			newGeneration[ADDRESS(id.x, id.y, id.z, size)].content[i] = 0.0;
		}
	}
}

[numthreads(8, 16, 8)]
void UpdateX(uint3 id : SV_DispatchThreadID)
{
	newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)] = currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)];
	newGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)] = currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)];

	float volume = 0, volume2 = 0;

	[unroll(NUMBER_OF_ELEMENTS)]
	for (uint i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		volume += currentGeneration[ADDRESS((id.x * 2 + offset.x), (id.y - 1), id.z, size)].content[i];
	}

	if (SOLID == currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature ||
		SOLID == currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].temperature ||
		abs(volume) < 0.5)
	{
		return;
	}

	float mean, difference;

	volume = 0;
	volume2 = 0;

	[unroll(NUMBER_OF_ELEMENTS)]
	for (i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		mean = (currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i] + currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].content[i]) / 2.0;

		difference = (mean - currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i]) * Viscosities[i];

		if (abs(difference) < 0.01)
		{
			difference = 0.00;
		}

		if ((volume + currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i] + difference) > 1)
		{
			difference -= (volume + currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i] + difference - 1);
		}

		if ((volume2 + currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].content[i] - difference) > 1)
		{
			difference += (volume2 + currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].content[i] - difference - 1);
		}

		//if (amount > 0)
		//{
		//	float sumWeightedTemps = newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature * volume + currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].temperature * amount;
		//	newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature = sumWeightedTemps / (volume + amount);
		//}
		//else if (amount < 0)
		//{
		//	float sumWeightedTemps = newGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].temperature * volume - newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature * amount;
		//	newGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].temperature = sumWeightedTemps / (volume2 - amount);
		//}
		//else
		//{
		//	float diff = (newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature - newGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].temperature) / temperatureSpread;
		//	newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature -= diff / (volume + 1);
		//	newGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].temperature += diff / (volume2 + 1); 
		//}

		newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i] = currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i] + difference;
		volume += currentGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].content[i] + difference;

		newGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].content[i] = currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].content[i] - difference;
		volume2 += currentGeneration[ADDRESS((id.x * 2 + offset.x + 1), id.y, id.z, size)].content[i] - difference;
	}

	//if (id.x * 2 + offset.x == 8 && id.y == 1 && id.z == 8)
	//{
	//	newGeneration[ADDRESS((id.x * 2 + offset.x), id.y, id.z, size)].temperature = 120;
	//}
}

[numthreads(16, 8, 8)]
void UpdateY(uint3 id : SV_DispatchThreadID)
{
	newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)] = currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)];
	newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)] = currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)];

	if (SOLID == currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature || SOLID == currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature)
	{
		return;
	}

	float amount, bottom, volume = 0, volume2 = 0, difference;

	[unroll(NUMBER_OF_ELEMENTS)]
	for (uint i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		amount = (currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[i] + currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].content[i]);
		bottom = min(1 - volume, min(Densities[i], 1) * amount);

		difference = bottom - currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[i];

		//if (difference > 0)
		//{
		//	float sumWeightedTemps = newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature * currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].volume + currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature * difference;
		//	newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature = sumWeightedTemps / (float)(currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].volume + difference);
		//}

		newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[i] += difference;

		volume += bottom;

		difference = amount - bottom - currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].content[i];

		//if (difference > 0)
		//{
		//	float sumWeightedTemps = newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature * currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].volume + currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature * difference;
		//	newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature = sumWeightedTemps / (float)(currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].volume + difference);
		//}

		newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].content[i] += difference;

		//float tempDifference = (newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature - newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature) / temperatureSpread;
		//newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature += tempDifference / ((float)newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].volume + 1);
		//newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].temperature -= tempDifference / ((float)newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].volume + 1);
	}

	[unroll(NUMBER_OF_ELEMENTS)]
	for (i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		if (newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[i] > 0)
		{
			if (currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature >= AggregationChangeTemperatures[i].x)
			{
				newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature -= 2;
				newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[i] -= 0.2;
				newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[AggregationChangeElements[i].x] += 0.2;
			}
			if (currentGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature < AggregationChangeTemperatures[i].y)
			{
				newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature += 2;
				newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[i] -= 0.2;
				newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[AggregationChangeElements[i].y] += 0.2;
			}
		}
	}

	if (id.x == fill.x && id.y * 2 + offset.y == fill.y && id.z == fill.z)
	{
		newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].content[fill.w] += 0.2;
	}

	if (id.x == fill.x && id.y * 2 + offset.y + 1 == fill.y && id.z == fill.z)
	{
		newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y + 1), id.z, size)].content[fill.w] += 0.2;
	}

	//if (id.x == 8 && id.y * 2 + offset.y == 1 && id.z == 8)
	//{
	//	newGeneration[ADDRESS(id.x, (id.y * 2 + offset.y), id.z, size)].temperature = 120;
	//}
}

[numthreads(16, 16, 4)]
void UpdateZ(uint3 id : SV_DispatchThreadID)
{
	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)] = currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)];
	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)] = currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)];

	float volume = 0, volume2 = 0;

	[unroll(NUMBER_OF_ELEMENTS)]
	for (uint i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		volume += currentGeneration[ADDRESS(id.x, (id.y - 1), (id.z * 2 + offset.z), size)].content[i];
	}

	if (SOLID == currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature ||
		SOLID == currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].temperature ||
		abs(volume) < 0.5)
	{
		return;
	}

	float mean, difference;

	volume = 0;
	volume2 = 0;

	[unroll(NUMBER_OF_ELEMENTS)]
	for (i = NUMBER_OF_ELEMENTS - 1; i >= 0; --i)
	{
		mean = (currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i] + currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].content[i]) / 2.0;

		difference = (mean - currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i]) * Viscosities[i];

		if (abs(difference) < 0.01)
		{
			difference = 0.00;
		}

		if ((volume + currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i] + difference) > 1)
		{
			difference -= (volume + currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i] + difference - 1);
		}

		if ((volume2 + currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].content[i] - difference) > 1)
		{
			difference += (volume2 + currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].content[i] - difference - 1);
		}

		//if (amount > 0)
		//{
		//	float sumWeightedTemps = newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature * volume + currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].temperature * amount;
		//	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature = sumWeightedTemps / (volume + amount);
		//}
		//else if (amount < 0)
		//{
		//	float sumWeightedTemps = newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].temperature * volume2 - newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature * amount;
		//	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].temperature = sumWeightedTemps / (volume2 - amount);
		//}
		//else
		//{
		//	float diff = (newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature - newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].temperature) / temperatureSpread;
		//	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature -= diff / (volume + 1);
		//	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].temperature += diff / (volume2 + 1);
		//}

		newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i] = currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i] + difference;
		volume += currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].content[i] + difference;

		newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].content[i] = currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].content[i] - difference;
		volume2 += currentGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z + 1), size)].content[i] - difference;
	}

	//if (id.x == 8 && id.y == 1 && id.z * 2 + offset.z == 8)
	//{
	//	newGeneration[ADDRESS(id.x, id.y, (id.z * 2 + offset.z), size)].temperature = 120;
	//}
}

