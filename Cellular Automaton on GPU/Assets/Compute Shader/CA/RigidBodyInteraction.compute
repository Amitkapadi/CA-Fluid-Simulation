#pragma kernel CSMain
#pragma kernel CSMain2

#define NUMBER_OF_ELEMENTS 3
#define ADDRESS(x,y,z,size) x + y * size[0] + z * size[0] * size[1]

struct Cell
{
	float content[NUMBER_OF_ELEMENTS];
	float volume;
	float temperature;
};

struct RigidBody
{
	//float2 size;
	float3 position;
	//float2 rotation;
};

static float3x3 I =
{
	{ 1, 0, 0 },
	{ 0, 1, 0 },
	{ 0, 0, 1 }
};

RWStructuredBuffer<float3> newPositions;

RWStructuredBuffer<RigidBody> newPositions2;

uint3 size;
StructuredBuffer<Cell> currentGeneration;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 pos = newPositions[id.x];

	uint3 cellPos = uint3(pos);

	float volume = currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z, size)].volume;
	
	if (volume > 0.01)
	{
		pos.y = cellPos.y + volume;
	}
	else if(volume < 0.01 && currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume > -0.5)
	{
		pos.y -= (1 - currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume);
	}

	if(currentGeneration[ADDRESS((cellPos.x + 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x += clamp(volume - currentGeneration[ADDRESS(cellPos.x + 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS((cellPos.x - 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x -= clamp(volume - currentGeneration[ADDRESS(cellPos.x - 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z + 1), size)].volume > -0.1)
		pos.z += clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z + 1, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z - 1), size)].volume > -0.1)
		pos.z -= clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z - 1, size)].volume, 0, 1);

	newPositions[id.x] = pos;
}


[numthreads(1, 1, 1)]
void CSMain2(uint3 id : SV_DispatchThreadID)
{
	float3 pos = newPositions2[id.x].position;

	uint3 cellPos = uint3(pos);

	float volume = currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z, size)].volume;

	if (volume > 0.01)
	{
		pos.y = cellPos.y + volume;
	}
	else if (volume < 0.01 && currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume > -0.5)
	{
		pos.y -= (1 - currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume);
	}

	if (currentGeneration[ADDRESS((cellPos.x + 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x += clamp(volume - currentGeneration[ADDRESS(cellPos.x + 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS((cellPos.x - 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x -= clamp(volume - currentGeneration[ADDRESS(cellPos.x - 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z + 1), size)].volume > -0.1)
		pos.z += clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z + 1, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z - 1), size)].volume > -0.1)
		pos.z -= clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z - 1, size)].volume, 0, 1);

	newPositions2[id.x].position = pos;

	//float3 oldPos[3] = { newPositions2[id.x].position + float3(-newPositions2[id.x].size.x / 2.0, 0, 0), newPositions2[id.x].position + float3(newPositions2[id.x].size.x / 2.0, 0, newPositions2[id.x].size.y / 2.0), newPositions2[id.x].position + float3(newPositions2[id.x].size.x / 2.0, 0, -newPositions2[id.x].size.x / 2.0) };
	//float3 newPos[3];

	//[unroll(3)]
	//for (int i = 0; i < 3; ++i)
	//{
	//	pos = oldPos[i];

	//	cellPos = uint3(pos);

	//	volume = currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z, size)].volume;

	//	pos.y = cellPos.y + clamp(volume, 0, 1);

	//	newPos[i] = pos;
	//}

	//float3 n = cross(newPos[2] - newPos[0], newPos[1] - newPos[0]);

	//float yAngle = acos(dot(float3(0, 1, 0), normalize(n)));
	//float zAngle = acos(dot(float3(0, 0, 1), float3(n.x, 0, n.z)));

	//newPositions2[id.x].rotation = float2(180+degrees(yAngle), degrees(zAngle));
}