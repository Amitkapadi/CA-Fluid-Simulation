#pragma kernel CSMain
#pragma kernel CSMain2

#define NUMBER_OF_ELEMENTS 3
#define ADDRESS(x,y,z,size) x + y * size[0] + z * size[0] * size[1]

struct Cell
{
	float content[NUMBER_OF_ELEMENTS];
	float volume;
	float temperature;
};

struct RigidBody
{
	float2 size;
	float3 position;
	float3x3 rotation;
};

static float3x3 I =
{
	{ 1, 0, 0 },
	{ 0, 1, 0 },
	{ 0, 0, 1 }
};

RWStructuredBuffer<float3> newPositions;

RWStructuredBuffer<RigidBody> newPositions2;

uint3 size;
StructuredBuffer<Cell> currentGeneration;

[numthreads(1,1,1)]
void CSMain (uint3 id : SV_DispatchThreadID)
{
	float3 pos = newPositions[id.x];

	uint3 cellPos = uint3(pos);

	float volume = currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z, size)].volume;
	
	if (volume > 0.01)
	{
		pos.y = cellPos.y + volume;
	}
	else if(volume < 0.01 && currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume > -0.5)
	{
		pos.y -= (1 - currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume);
	}

	if(currentGeneration[ADDRESS((cellPos.x + 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x += clamp(volume - currentGeneration[ADDRESS(cellPos.x + 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS((cellPos.x - 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x -= clamp(volume - currentGeneration[ADDRESS(cellPos.x - 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z + 1), size)].volume > -0.1)
		pos.z += clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z + 1, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z - 1), size)].volume > -0.1)
		pos.z -= clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z - 1, size)].volume, 0, 1);

	newPositions[id.x] = pos;
}


[numthreads(1, 1, 1)]
void CSMain2(uint3 id : SV_DispatchThreadID)
{
	float3 pos = newPositions2[id.x].position;

	uint3 cellPos = uint3(pos);

	float volume = currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z, size)].volume;

	if (volume > 0.01)
	{
		pos.y = cellPos.y + volume;
	}
	else if (volume < 0.01 && currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume > -0.5)
	{
		pos.y -= (1 - currentGeneration[ADDRESS(cellPos.x, (cellPos.y - 1), cellPos.z, size)].volume);
	}

	if (currentGeneration[ADDRESS((cellPos.x + 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x += clamp(volume - currentGeneration[ADDRESS(cellPos.x + 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS((cellPos.x - 1), cellPos.y, cellPos.z, size)].volume > -0.1)
		pos.x -= clamp(volume - currentGeneration[ADDRESS(cellPos.x - 1, cellPos.y, cellPos.z, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z + 1), size)].volume > -0.1)
		pos.z += clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z + 1, size)].volume, 0, 1);

	if (currentGeneration[ADDRESS(cellPos.x, cellPos.y, (cellPos.z - 1), size)].volume > -0.1)
		pos.z -= clamp(volume - currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z - 1, size)].volume, 0, 1);

	newPositions2[id.x].position = pos;

	float3 oldPos[3] = { newPositions2[id.x].position + float3(-newPositions2[id.x].size.x / 2.0, 0, 0), newPositions2[id.x].position + float3(newPositions2[id.x].size.x / 2.0, 0, newPositions2[id.x].size.y / 2.0), newPositions2[id.x].position + float3(newPositions2[id.x].size.x / 2.0, 0, -newPositions2[id.x].size.x / 2.0) };
	float3 newPos[3];

	[unroll(3)]
	for (int i = 0; i < 3; ++i)
	{
		pos = oldPos[i];

		cellPos = uint3(pos);

		volume = currentGeneration[ADDRESS(cellPos.x, cellPos.y, cellPos.z, size)].volume;

		pos.y = cellPos.y + clamp(volume, 0, 1);

		newPos[i] = pos;
	}

	float3 n = cross(newPos[2] - newPos[0], newPos[1] - newPos[0]);
	float3 up = float3(0, 1, 0);

	float3 x = normalize(cross(up, n));
	
	float theta = acos(dot(up, n) / (length(n)));

	float3x3 A;
	A._11 = 0;
	A._12 = -x.z;
	A._13 = x.y;

	A._21 = x.z;
	A._22 = 0;
	A._23 = -x.x;

	A._31 = -x.y;
	A._32 = x.x;
	A._33 = 0;

	float3x3 R = I + sin(theta) * A + (1 - cos(theta)) * A * A;

	newPositions2[id.x].rotation = I;
}